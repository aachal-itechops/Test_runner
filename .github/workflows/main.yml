name: "üöÄ Manual Deploy (Frontend & Backend from Release ZIPs)"

on:
  workflow_dispatch:
    inputs:
      runner:
        description: "Select the self-hosted runner to deploy on"
        required: true
        type: choice
        options:
          - host24-frontend
          - host24-backend
          - AWS_Staging
          - DESKTOP-Q4SDOI5
          - ARB

      domain:
        description: "Enter the target domain (e.g., qa.arborgold.net)"
        required: true

      app_type:
        description: "Deployment Type: frontend, backend, or both"
        required: true
        type: choice
        options:
          - frontend
          - backend
          - both

      release_tag:
        description: "Enter the GitHub Release tag (e.g., release/V10.0.3)"
        required: true

      restart_iis:
        description: "Restart IIS AppPools before & after Deployment?"
        required: false
        type: boolean

permissions:
  contents: read

jobs:
  deploy:
    # üéØ CORRECTED RUNS-ON: Single expression covering all runner choices.
    # When 'ARB' is selected, this evaluates to: ["self-hosted", "Windows", "X64"]
    runs-on: ${{ fromJson('{"host24-frontend":["self-hosted","frontend"],"host24-backend":["self-hosted","backend"],"AWS_Staging":["self-hosted","AWS_Staging"],"DESKTOP-Q4SDOI5":["self-hosted","Windows","X64"],"ARB":["self-hosted","Windows","X64"]}') [github.event.inputs.runner] }}

    steps:
      - name: "üì• Checkout Repository"
        uses: actions/checkout@v4

      - name: "‚öôÔ∏è Ensure GitHub CLI Installed (ZIP fallback)"
        shell: pwsh
        run: |
          # if gh CLI not installed, download ZIP version
          if (-not (Get-Command gh -ErrorAction SilentlyContinue)) {
            Write-Host "üì¶ Installing GitHub CLI..."
            $version = "2.56.0"
            $zipUrl = "https://github.com/cli/cli/releases/download/v$version/gh_${version}_windows_amd64.zip"
            $zipPath = "$env:TEMP\ghcli.zip"
            $extractPath = "$env:ProgramData\ghcli"
            if (Test-Path $extractPath) { Remove-Item -Recurse -Force $extractPath }
            if (Test-Path $zipPath) { Remove-Item -Force $zipPath }
            Invoke-WebRequest -Uri $zipUrl -OutFile $zipPath
            Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force
            $ghExe = Get-ChildItem -Path $extractPath -Filter gh.exe -Recurse | Select-Object -First 1
            if (-not $ghExe) { Write-Error "‚ùå gh.exe missing"; exit 1 }
            echo "$($ghExe.DirectoryName)" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
            & "$($ghExe.FullName)" --version
          } else {
            Write-Host "‚úÖ GitHub CLI exists: $(gh --version | Select-String 'gh version')"
          }

      - name: "üßæ Download ZIP Assets from GitHub Release"
        id: download
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $tag = "${{ github.event.inputs.release_tag }}"
          Write-Host "üì• Downloading assets for release $tag..."
          gh release download $tag --repo "${{ github.repository }}" --pattern "*.zip"
          $downloadDir = "$PWD\release_zips"
          if (Test-Path $downloadDir) { Remove-Item -Recurse -Force $downloadDir }
          New-Item -ItemType Directory -Path $downloadDir | Out-Null
          Move-Item *.zip $downloadDir -Force
          $count = (Get-ChildItem -Path $downloadDir -Filter *.zip).Count
          if ($count -eq 0) { Write-Error "‚ùå No ZIP files found for release $tag"; exit 1 }
          Write-Host "‚úÖ Downloaded $count ZIP file(s) to $downloadDir"
          echo "download_dir=$downloadDir" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: "üì¶ Extract ZIPs to Separate Folders (Frontend & Backend)"
        id: extract
        shell: pwsh
        run: |
          $source = "${{ steps.download.outputs.download_dir }}"
          $extractRoot = "$PWD\deploy"
          if (Test-Path $extractRoot) { Remove-Item -Recurse -Force $extractRoot }
          New-Item -ItemType Directory -Path $extractRoot | Out-Null

          # Separate folders for frontend and backend
          $frontendFolder = Join-Path $extractRoot "frontend"
          $backendFolder  = Join-Path $extractRoot "backend"
          New-Item -ItemType Directory -Path $frontendFolder | Out-Null
          New-Item -ItemType Directory -Path $backendFolder | Out-Null

          foreach ($zip in Get-ChildItem -Path $source -Filter *.zip) {
            # Determine if it's frontend or backend from zip name
            if ($zip.BaseName -match "(?i)frontend") {
              $dest = Join-Path $frontendFolder $zip.BaseName
            } elseif ($zip.BaseName -match "(?i)backend") {
              $dest = Join-Path $backendFolder $zip.BaseName
            } else {
              # Default: put in frontend (you can adjust this logic)
              $dest = Join-Path $frontendFolder $zip.BaseName
            }
            Write-Host "üì¶ Extracting $($zip.Name) ‚Üí $dest"
            Expand-Archive -Path $zip.FullName -DestinationPath $dest -Force
          }

          echo "extract_root=$extractRoot" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: "üöÄ Deploy to IIS Domain"
        id: deploy
        shell: pwsh
        run: |
          # Ensure WebAdministration module is loaded for IIS commands
          Import-Module WebAdministration -ErrorAction SilentlyContinue

          $domain = "${{ github.event.inputs.domain }}"
          $app_type = "${{ github.event.inputs.app_type }}"
          $restart = "${{ github.event.inputs.restart_iis }}"
          $root = "${{ steps.extract.outputs.extract_root }}"

          Write-Host "==============================="
          Write-Host "üöÄ DEPLOYMENT STARTED"
          Write-Host "üåç Domain: $domain"
          Write-Host "üîπ Type: $app_type"
          Write-Host "==============================="

          # Define deployment maps
          $frontendMap = @{
            "ag-app"              = "AG"
            "web-arborgold-crew"  = "Crew"
            "e-proposal"          = "EProposal"
            "e-invoice"           = "EInvoice"
            "e-statement"         = "EStatement"
          }

          $backendMap = @{
            "backend-app"         = "AG"
            # Add other backend folders here
          }

          # Select which map to use and the source root
          switch ($app_type) {
            "frontend" { $deployMap = $frontendMap; $srcRoot = Join-Path $root "frontend" }
            "backend"  { $deployMap = $backendMap;  $srcRoot = Join-Path $root "backend" }
            "both"     { 
              $deployMap = @{}
              $frontendMap.GetEnumerator() | ForEach-Object { $deployMap[$_.Key] = $_.Value }
              $backendMap.GetEnumerator() | ForEach-Object { $deployMap[$_.Key] = $_.Value }
              $srcRoot = $root
            }
          }

          foreach ($key in $deployMap.Keys) {
            $src = Join-Path $srcRoot "$($key)"
            $target = "D:\inetpub\vhosts\$domain\httpdocs\$($deployMap[$key])"
            $appPoolName = $domain # Assuming AppPool name is the domain name

            if (-not (Test-Path $src)) {
              Write-Warning "‚ö†Ô∏è Source folder missing: $src ‚Äî skipping"
              continue
            }

            if (-not (Test-Path $target)) {
              Write-Host "üìÅ Creating directory $target ..."
              New-Item -ItemType Directory -Force -Path $target | Out-Null
            }

            if ($restart -eq "true" -and (Get-WebAppPoolState $appPoolName).Value -eq "Started") {
              Write-Host "üõë Stopping AppPool $appPoolName..."
              Stop-WebAppPool $appPoolName -ErrorAction SilentlyContinue
            }

            Write-Host "üöö Copying $key ‚Üí $target ..."
            Copy-Item "$src\*" -Destination $target -Recurse -Force -ErrorAction Stop
            Write-Host "‚úÖ $key deployed successfully."

            if ($restart -eq "true") {
              Write-Host "‚ñ∂Ô∏è Starting AppPool $appPoolName..."
              Start-WebAppPool $appPoolName -ErrorAction SilentlyContinue
            }
          }

          Write-Host "üéâ Deployment to $domain completed!"

      - name: "üßπ Cleanup temporary files"
        if: always()
        shell: pwsh
        run: |
          Write-Host "üßπ Starting cleanup..."
          # Explicitly remove the temporary folders
          Remove-Item "$PWD\release_zips" -Recurse -Force -ErrorAction SilentlyContinue
          Remove-Item "$PWD\deploy" -Recurse -Force -ErrorAction SilentlyContinue
          Write-Host "üßπ Cleanup completed."
