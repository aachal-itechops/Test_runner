name: "üöö Manual Backend/Frontend Deploy"

on:
  workflow_dispatch:
    inputs:
      host:
        description: "Select target host / runner"
        required: true
        type: choice
        options:
          - host24-backend
          - host24-frontend
          - host24-zip
          - AWS_Staging
          - AWS_PROD_01
          - AWS_PROD_02
          - AWS_PROD_03
          - AWS_PROD_04
          - AWS_PROD_05
          - test_runner

      domain:
        description: "Comma-separated domain(s)."
        required: false

      exclude_domains:
        description: "Comma-separated domains to exclude manually"
        required: false

      restart_iis:
        description: "Restart IIS before & after Deployment?"
        required: false
        type: boolean

      app_type:
        description: "Deployment Type"
        required: true
        type: choice
        options:
          - backend
          - frontend
          - both

      release_tag:
        description: "GitHub Release tag (optional for local test)"
        required: false

permissions:
  contents: read

jobs:
  deploy:
    runs-on: [self-hosted]

    steps:
      - name: "üì• Checkout Repository"
        uses: actions/checkout@v4

      - name: "‚öôÔ∏è Ensure GH CLI (for local test fallback)"
        shell: pwsh
        run: |
          if (-not (Get-Command gh -ErrorAction SilentlyContinue)) {
            Write-Host "‚ö†Ô∏è GH CLI not found. Skipping release download for local test."
          }

      - name: "üßæ Download & Prepare ZIPs"
        id: download
        shell: pwsh
        run: |
          $tag="${{ github.event.inputs.release_tag }}"
          $downloadDir="$PWD/release_zips"

          # Create folder for testing locally
          if (-not (Get-Command gh -ErrorAction SilentlyContinue)) {
            if (Test-Path $downloadDir) { Remove-Item -Recurse -Force $downloadDir }
            New-Item -ItemType Directory -Path $downloadDir | Out-Null

            # Example dummy files
            New-Item -ItemType Directory -Path "$downloadDir/frontend" | Out-Null
            New-Item -ItemType File -Path "$downloadDir/frontend/index.html" | Out-Null
            New-Item -ItemType Directory -Path "$downloadDir/backend" | Out-Null
            New-Item -ItemType File -Path "$downloadDir/backend/api.dll" | Out-Null
          } else {
            gh release download $tag --repo "${{ github.repository }}" --pattern "*.zip" --clobber
            if (Test-Path $downloadDir) { Remove-Item -Recurse -Force $downloadDir }
            New-Item -ItemType Directory -Path $downloadDir | Out-Null
            Move-Item *.zip $downloadDir -Force
          }

          echo "download_dir=$downloadDir" >> $env:GITHUB_OUTPUT

      - name: "üì¶ Extract & Merge ZIPs"
        id: extract
        shell: pwsh
        run: |
          $src="${{ steps.download.outputs.download_dir }}"
          $root="$PWD/deploy"
          if (Test-Path $root) { Remove-Item -Recurse -Force $root }
          New-Item -ItemType Directory -Path $root | Out-Null

          $merged="$root/merged"
          New-Item -ItemType Directory -Path $merged | Out-Null

          foreach ($item in Get-ChildItem $src) {
            Copy-Item $item.FullName $merged -Recurse -Force
          }

          echo "extract_root=$merged" >> $env:GITHUB_OUTPUT

      - name: "üöÄ Deploy to Domains"
        shell: pwsh
        run: |
          $source="${{ steps.extract.outputs.extract_root }}"
          $domains=(${{ github.event.inputs.domain }} -split ",") | ForEach-Object { $_.Trim() }
          $exclude=(${{ github.event.inputs.exclude_domains }} -split ",") | ForEach-Object { $_.Trim() }
          $restart="${{ github.event.inputs.restart_iis }}"
          $type="${{ github.event.inputs.app_type }}"

          if ($domains.Count -eq 0) { Write-Host "‚ö†Ô∏è No domains to deploy"; exit 0 }
          $domains=$domains | Where-Object { $exclude -notcontains $_ }

          foreach ($domain in $domains) {
              $targets=@()
              switch ($type) {
                  "frontend" { $targets+= @{ Source = Join-Path $source "frontend"; Destination = "D:\inetpub\vhosts\$domain\httpdocs" } }
                  "backend"  { $targets+= @{ Source = Join-Path $source "backend"; Destination = "D:\inetpub\vhosts\$domain\httpdocs\AG" } }
                  "both" {
                      $targets+= @{ Source = Join-Path $source "frontend"; Destination = "D:\inetpub\vhosts\$domain\httpdocs" }
                      $targets+= @{ Source = Join-Path $source "backend"; Destination = "D:\inetpub\vhosts\$domain\httpdocs\AG" }
                  }
              }

              foreach ($target in $targets) {
                  Write-Host "üìÇ Deploying from $($target.Source) ‚Üí $($target.Destination)"
                  if (-not (Test-Path $target.Destination)) { New-Item -ItemType Directory -Path $target.Destination -Force | Out-Null }
                  Copy-Item "$($target.Source)\*" $target.Destination -Recurse -Force
              }
          }

      - name: "üßπ Cleanup workspace"
        if: always()
        shell: pwsh
        run: |
          Remove-Item "$PWD/release_zips" -Recurse -Force -ErrorAction SilentlyContinue
          Remove-Item "$PWD/deploy" -Recurse -Force -ErrorAction SilentlyContinue
          Write-Host "üßπ Cleanup done"
